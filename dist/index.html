<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Alen</title>
    <link rel="icon" type="image/png" href="./favicon.png">
    <link rel="stylesheet" href="./style.css?v=alen9">
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Orbitron:wght@500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  </head>
    
  <body>
    <audio id="bgMusic" loop preload="auto">
      <source src="./bg-music.mp3" type="audio/mpeg">
    </audio>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
      <div class="loading-spinner" id="loadingSpinner">
        <div><div><div><div><div><div><div><div><div><div></div></div></div></div></div></div></div></div></div></div>
      </div>
    </div>

    <!-- Glitch Overlay -->
    <div class="glitch-overlay" id="glitchOverlay">
      <div class="glitch-layer glitch-layer-1"></div>
      <div class="glitch-layer glitch-layer-2"></div>
      <div class="glitch-layer glitch-layer-3"></div>
    </div>
    
    <!-- Main Content -->
    <div class="main-content" id="mainContent" style="display: none;">
    <!-- Top Bar -->
    <div class="top-bar">
      <div class="top-bar-content">
        <div class="game-title-top">The Alen</div>
        <button type="button" class="sound-toggle" id="soundToggle" title="Sound on" aria-label="Toggle sound">
          <span class="sound-icon sound-on">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5L6 9H2v6h4l5 4V5z"/><path d="M15.5 8.5a3 3 0 0 1 0 7M18 6a6 6 0 0 1 0 12"/></svg>
          </span>
          <span class="sound-icon sound-off" style="display: none;">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5L6 9H2v6h4l5 4V5z"/><line x1="2" y1="2" x2="22" y2="22"/><path d="M22 12l-5 5M17 7l5 5"/></svg>
          </span>
        </button>
      </div>
    </div>

    <div class="app-container">
      <!-- Left Sidebar -->
      <div class="sidebar left-sidebar">
        <!-- Meet Alen Panel -->
        <div class="panel meet-alen-panel">
          <div class="panel-header">MEET ALEN</div>
          <div class="alen-image-container">
            <canvas id="alen3dCanvas" class="alen-3d-canvas"></canvas>
          </div>
        </div>

        <!-- Alen Stats -->
        <div class="panel alen-stats-panel">
          <div class="panel-header">ALEN STATS</div>
          <div class="alen-stats-content">
          <div class="stat-section-title">Core Parameters</div>
          <div class="stat-row">
            <span class="stat-label">Quantum Coherence</span>
            <div class="stat-bar-wrapper">
              <div class="stat-bar quantum-bar" style="width: 87%"></div>
            </div>
            <span class="stat-value">87/100</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Plasma Stability</span>
            <div class="stat-bar-wrapper">
              <div class="stat-bar plasma-bar" style="width: 92%"></div>
            </div>
            <span class="stat-value">92/100</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Neural Sync</span>
            <div class="stat-bar-wrapper">
              <div class="stat-bar neural-bar" style="width: 78%"></div>
            </div>
            <span class="stat-value">78/100</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Dimensional Anchor</span>
            <div class="stat-bar-wrapper">
              <div class="stat-bar anchor-bar" style="width: 95%"></div>
            </div>
            <span class="stat-value">95/100</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Bio-Energy Field</span>
            <div class="stat-bar-wrapper">
              <div class="stat-bar bio-bar" style="width: 83%"></div>
            </div>
            <span class="stat-value">83/100</span>
          </div>

          <div class="stat-section-title" style="margin-top: 20px;">Consciousness Metrics</div>
          <div class="stat-row">
            <span class="stat-label">Cosmic Awareness</span>
            <div class="stat-bar-wrapper">
              <div class="stat-bar awareness-bar" style="width: 91%"></div>
            </div>
            <span class="stat-value">91/100</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Temporal Alignment</span>
            <div class="stat-bar-wrapper">
              <div class="stat-bar temporal-bar" style="width: 76%"></div>
            </div>
            <span class="stat-value">76/100</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Reality Distortion</span>
            <div class="stat-bar-wrapper">
              <div class="stat-bar distortion-bar" style="width: 15%"></div>
            </div>
            <span class="stat-value">15/100</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Interdimensional Trust</span>
            <div class="stat-bar-wrapper">
              <div class="stat-bar interdimensional-bar" style="width: 88%"></div>
            </div>
            <span class="stat-value">88/100</span>
          </div>
          </div>
        </div>

      </div>

      <!-- Center Communication Area -->
      <div class="center-area">
        <div class="communication-panel">
          <div class="panel-header">COMMUNICATION INTERFACE</div>
          <div class="translator-section">
            <div class="translator-header">
              <span class="translator-header-icon">◇</span> To Alen Language
            </div>
            <div class="translator-controls">
              <label class="translator-label">Source</label>
              <select id="sourceLang" class="lang-select">
                <option value="en">English</option>
                <option value="zh">Chinese</option>
              </select>
              <span class="translator-arrow" aria-hidden="true">⚡</span>
              <label class="translator-label">Target</label>
              <select id="targetLang" class="lang-select">
                <option value="alien">Alen</option>
              </select>
            </div>
            <textarea id="inputText" class="translator-input" placeholder="Enter human text to encode..."></textarea>
            <button id="translateBtn" class="translate-button">
              <span class="translate-btn-icon">◈</span> Encode
            </button>
            <div class="translator-output-wrap">
              <div class="translator-output-label">Alen output</div>
              <div id="outputText" class="translator-output"></div>
              <button id="copyAlienBtn" class="copy-alien-btn" style="display: none;">Copy glyph</button>
            </div>
          </div>
          <div class="chat-section">
            <div class="chat-header">Conversation Log</div>
            <div id="chatMessages" class="chat-messages"></div>
            <div class="chat-input-area">
              <input type="text" id="chatInput" class="chat-input" placeholder="Ask Alen about civilizations...">
              <button id="sendBtn" class="send-button">Send</button>
            </div>
          </div>
        </div>

        <!-- Alen Physical Parameters -->
        <div class="panel alen-physical-panel">
          <div class="panel-header">PHYSICAL PARAMETERS</div>
          <div class="alen-physical-content">
            <div class="physical-params-top">
              <div class="physical-info-item">
                <span class="physical-info-label">Height</span>
                <span class="physical-info-value">14 ft</span>
              </div>
              <div class="physical-info-item">
                <span class="physical-info-label">Mass</span>
                <span class="physical-info-value">~280 kg</span>
              </div>
              <div class="physical-info-item">
                <span class="physical-info-label">Skin tone</span>
                <span class="physical-info-value">Translucent blue</span>
              </div>
              <div class="physical-info-item">
                <span class="physical-info-label">Eye count</span>
                <span class="physical-info-value">3</span>
              </div>
              <div class="physical-info-item">
                <span class="physical-info-label">Limb structure</span>
                <span class="physical-info-value">Hexapod</span>
              </div>
              <div class="physical-info-item">
                <span class="physical-info-label">Body temp</span>
                <span class="physical-info-value">-12°C</span>
              </div>
            </div>
            <div class="alen-character-image-wrapper physical-3d-wrapper">
              <canvas id="physical3dCanvas" class="physical-3d-canvas"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- Right Sidebar -->
      <div class="sidebar right-sidebar">
        <!-- Extraterrestrial Civilizations -->
        <div class="panel">
          <div class="panel-header">CIVILIZATIONS</div>
          <div class="civilization-list">
            <div class="civilization-item">
              <span class="civilization-icon">◆</span>
              <div class="civilization-info">
                <span class="civilization-name">Zeta Reticuli</span>
                <span class="civilization-desc">Advanced quantum civilization</span>
              </div>
            </div>
            <div class="civilization-item">
              <span class="civilization-icon">◇</span>
              <div class="civilization-info">
                <span class="civilization-name">Andromeda Sector</span>
                <span class="civilization-desc">Interdimensional beings</span>
              </div>
            </div>
            <div class="civilization-item">
              <span class="civilization-icon">◉</span>
              <div class="civilization-info">
                <span class="civilization-name">Pleiades Cluster</span>
                <span class="civilization-desc">Energy-based lifeforms</span>
              </div>
            </div>
            <div class="civilization-item">
              <span class="civilization-icon">◎</span>
              <div class="civilization-info">
                <span class="civilization-name">Orion Belt</span>
                <span class="civilization-desc">Ancient cosmic race</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Humanity Challenges -->
        <div class="panel">
          <div class="panel-header">HUMANITY CHALLENGES</div>
          <div class="challenge-list">
            <div class="challenge-item">
              <span class="challenge-icon">▸</span>
              <span class="challenge-text">Climate Transformation</span>
            </div>
            <div class="challenge-item">
              <span class="challenge-icon">▹</span>
              <span class="challenge-text">Genetic Evolution</span>
            </div>
            <div class="challenge-item">
              <span class="challenge-icon">►</span>
              <span class="challenge-text">AI Integration</span>
            </div>
            <div class="challenge-item">
              <span class="challenge-icon">▼</span>
              <span class="challenge-text">Space Colonization</span>
            </div>
            <div class="challenge-item">
              <span class="challenge-icon">◆</span>
              <span class="challenge-text">Energy Revolution</span>
            </div>
          </div>
        </div>

        <!-- Knowledge Base -->
        <div class="panel">
          <div class="panel-header">KNOWLEDGE BASE</div>
          <div class="knowledge-items">
            <div class="knowledge-item">
              <span class="knowledge-title">Quantum Communication</span>
              <span class="knowledge-desc">Instantaneous information transfer</span>
            </div>
            <div class="knowledge-item">
              <span class="knowledge-title">Dimensional Travel</span>
              <span class="knowledge-desc">Cross-reality navigation</span>
            </div>
            <div class="knowledge-item">
              <span class="knowledge-title">Consciousness Transfer</span>
              <span class="knowledge-desc">Mind-body separation technology</span>
            </div>
          </div>
        </div>

        <!-- Contact Links -->
        <div class="panel">
          <div class="panel-header">CONNECT</div>
          <div class="connect-buttons">
            <button class="connect-btn" id="xButton" title="Visit X">
              <img src="./x-icon.svg" alt="X" class="connect-icon">
              <span>X</span>
            </button>
            <button class="connect-btn" id="pumpfunButton" title="Visit Pump.fun">
              <img src="./pumpfun-icon.png" alt="Pump.fun" class="connect-icon">
              <span>Pump.fun</span>
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Start background music as soon as page opens
      (function() {
        function tryPlay() {
          var bgMusic = document.getElementById('bgMusic');
          if (bgMusic) {
            bgMusic.volume = 0.4;
            bgMusic.play().catch(function() {});
          }
        }
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', tryPlay);
        } else {
          tryPlay();
        }
      })();
    </script>
    <script>
      // Loading screen logic
      window.addEventListener('load', function() {
        setTimeout(function() {
          const loadingScreen = document.getElementById('loadingScreen');
          const mainContent = document.getElementById('mainContent');
          
          if (loadingScreen && mainContent) {
            loadingScreen.style.opacity = '0';
            loadingScreen.style.transition = 'opacity 0.5s ease-out';
            
            setTimeout(function() {
              loadingScreen.style.display = 'none';
              mainContent.style.display = 'block';
              mainContent.style.animation = 'fadeIn 0.5s ease-out';
              var bgMusic = document.getElementById('bgMusic');
              if (bgMusic && bgMusic.paused) {
                bgMusic.volume = 0.4;
                bgMusic.play().catch(function() {});
              }
            }, 500);
          }
        }, 1500); // Show loading for 1.5 seconds
      });

      document.addEventListener('DOMContentLoaded', function() {
        var bgMusic = document.getElementById('bgMusic');
        var soundToggle = document.getElementById('soundToggle');
        var soundOnEl = soundToggle && soundToggle.querySelector('.sound-on');
        var soundOffEl = soundToggle && soundToggle.querySelector('.sound-off');
        if (soundToggle && bgMusic) {
          soundToggle.addEventListener('click', function() {
            bgMusic.muted = !bgMusic.muted;
            if (!bgMusic.muted && bgMusic.paused) {
              bgMusic.volume = 0.4;
              bgMusic.play().catch(function() {});
            }
            if (soundOnEl) soundOnEl.style.display = bgMusic.muted ? 'none' : 'inline';
            if (soundOffEl) soundOffEl.style.display = bgMusic.muted ? 'inline' : 'none';
            soundToggle.setAttribute('aria-label', bgMusic.muted ? 'Sound off (click to turn on)' : 'Sound on (click to turn off)');
          });
        }

        var glitchOverlay = document.getElementById('glitchOverlay');
        var mainContent = document.getElementById('mainContent');
        var loadingScreen = document.getElementById('loadingScreen');
        if (glitchOverlay) {
          function triggerGlitch() {
            glitchOverlay.classList.add('active');
            if (mainContent && mainContent.style.display !== 'none') {
              mainContent.classList.add('glitch-active');
            }
            if (loadingScreen && loadingScreen.style.display !== 'none') {
              loadingScreen.classList.add('glitch-active');
            }
            setTimeout(function() {
              glitchOverlay.classList.remove('active');
              if (mainContent) {
                mainContent.classList.remove('glitch-active');
              }
              if (loadingScreen) {
                loadingScreen.classList.remove('glitch-active');
              }
            }, 500);
          }
          setInterval(triggerGlitch, 7000);
          triggerGlitch();
        }
      });
    </script>
    <script>
      // Device buttons functionality
      document.addEventListener('DOMContentLoaded', function() {
        // Alien Language Translator
        function translateToAlien(text) {
          // Simple alien language transformation
          const alienMap = {
            'a': 'α', 'e': 'ε', 'i': 'ι', 'o': 'ω', 'u': 'υ',
            'A': 'Α', 'E': 'Ε', 'I': 'Ι', 'O': 'Ω', 'U': 'Υ',
            ' ': ' ⚡ ', '.': ' ◊ ', '?': ' ◇ ', '!': ' ◆ '
          };
          let alienText = text.split('').map(char => {
            return alienMap[char] || char;
          }).join('');
          return alienText + ' ⚡◊◆';
        }

        // Translator functionality
        const translateBtn = document.getElementById('translateBtn');
        const inputText = document.getElementById('inputText');
        const outputText = document.getElementById('outputText');
        const sourceLang = document.getElementById('sourceLang');

        if (translateBtn && inputText && outputText) {
          const copyAlienBtn = document.getElementById('copyAlienBtn');
          translateBtn.addEventListener('click', function() {
            const text = inputText.value.trim();
            if (text) {
              const alienTranslation = translateToAlien(text);
              outputText.textContent = alienTranslation;
              outputText.style.display = 'block';
              if (copyAlienBtn) {
                copyAlienBtn.style.display = 'inline-block';
              }
            }
          });

          if (copyAlienBtn) {
            copyAlienBtn.addEventListener('click', function() {
              const t = outputText.textContent;
              if (t) {
                navigator.clipboard.writeText(t).then(function() {
                  copyAlienBtn.textContent = 'Copied!';
                  setTimeout(function() { copyAlienBtn.textContent = 'Copy'; }, 1500);
                });
              }
            });
          }

          inputText.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && e.ctrlKey) {
              translateBtn.click();
            }
          });
        }

        // Chat functionality (ChatGPT API via /api/chat — Alen responds in alien language)
        const sendBtn = document.getElementById('sendBtn');
        const chatInput = document.getElementById('chatInput');
        const chatMessages = document.getElementById('chatMessages');

        function addChatMessage(text, isUser) {
          const messageDiv = document.createElement('div');
          messageDiv.className = isUser ? 'chat-message user' : 'chat-message alien';
          messageDiv.textContent = text;
          if (chatMessages) {
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
          }
        }

        function fallbackAlienReply() {
          const fallbacks = [
            'Ηυmαn ⚡ ωυαντ ◊ κνωωλεδγε ◆ αλφα ετα ◊ ⚡◊◆',
            'Θε ωσταrσ ◊ τελλ υσ ◆ μορε ⚡◊◆',
            'Ωυr ◊ χιβιλιζατιον ◊ ωαιτσ ◆ ⚡◊◆'
          ];
          return fallbacks[Math.floor(Math.random() * fallbacks.length)];
        }

        if (sendBtn && chatInput && chatMessages) {
          sendBtn.addEventListener('click', async function() {
            const text = chatInput.value.trim();
            if (!text) return;
            addChatMessage(text, true);
            chatInput.value = '';
            addChatMessage('Alen: …', false);
            const placeholder = chatMessages.lastElementChild;

            try {
              const base = window.location.origin;
              const res = await fetch(base + '/api/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: text })
              });
              const data = await res.json();
              const reply = (data.reply && data.reply.trim()) ? data.reply : fallbackAlienReply();
              if (placeholder && placeholder.textContent === 'Alen: …') {
                placeholder.textContent = 'Alen: ' + reply;
              } else {
                addChatMessage('Alen: ' + reply, false);
              }
            } catch (e) {
              if (placeholder && placeholder.textContent === 'Alen: …') {
                placeholder.textContent = 'Alen: ' + fallbackAlienReply();
              } else {
                addChatMessage('Alen: ' + fallbackAlienReply(), false);
              }
            }
          });

          chatInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
              sendBtn.click();
            }
          });
        }

        // X button - redirect to X
        const xButton = document.getElementById('xButton');
        if (xButton) {
          xButton.addEventListener('click', function() {
            window.open('https://x.com/thea1en', '_blank');
          });
        }

        // Pump.fun button - redirect to Pump.fun
        const pumpfunButton = document.getElementById('pumpfunButton');
        if (pumpfunButton) {
          pumpfunButton.addEventListener('click', function() {
            window.open('https://pump.fun/coin/FyeZy8XQPQXWnhj9jBbDVY4kbVK5hKjbpKZQf2ECpump', '_blank');
          });
        }


        // Initialize welcome message
        setTimeout(() => {
          if (chatMessages) {
            addChatMessage('Alen: Greetings, human. I am Alen from another planet. I will share knowledge about extraterrestrial civilizations and discuss the challenges facing your species.', false);
          }
        }, 2000);

        // Initialize Alen 3D Model
        let alen3DInitialized = false;
        function initAlen3D() {
          if (alen3DInitialized) return;
          
          const canvas = document.getElementById('alen3dCanvas');
          if (!canvas) {
            console.log('Alen canvas not found, retrying...');
            setTimeout(initAlen3D, 200);
            return;
          }
          
          if (typeof THREE === 'undefined') {
            console.log('THREE.js not loaded, retrying...');
            setTimeout(initAlen3D, 200);
            return;
          }

          if (typeof THREE.GLTFLoader === 'undefined' && typeof GLTFLoader === 'undefined') {
            console.log('GLTFLoader not loaded, trying to load...');
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js';
            script.onload = function() {
              console.log('GLTFLoader script loaded, checking availability...');
              setTimeout(function() {
                if (typeof THREE.GLTFLoader !== 'undefined') {
                  console.log('THREE.GLTFLoader is available');
                  setTimeout(initAlen3D, 100);
                } else if (typeof GLTFLoader !== 'undefined') {
                  console.log('GLTFLoader is available');
                  setTimeout(initAlen3D, 100);
                } else {
                  console.error('GLTFLoader loaded but not accessible');
                  setTimeout(initAlen3D, 500);
                }
              }, 200);
            };
            script.onerror = function() {
              console.error('Failed to load GLTFLoader script');
              setTimeout(initAlen3D, 1000);
            };
            document.head.appendChild(script);
            return;
          }

          const container = canvas.parentElement;
          if (!container) {
            console.log('Container not found, retrying...');
            setTimeout(initAlen3D, 200);
            return;
          }
          
          const width = container.clientWidth || 300;
          const height = container.clientHeight || 300;
          
          if (width === 0 || height === 0) {
            console.log('Container has zero size, retrying...', width, height);
            setTimeout(initAlen3D, 200);
            return;
          }
          
          alen3DInitialized = true;
          console.log('Initializing Alen 3D model...');

          // Scene setup
          const scene = new THREE.Scene();

          const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
          camera.position.set(0, 0, 3);

          const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
          renderer.setSize(width, height);
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.setClearColor(0x000000, 0);

          // Lighting
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          scene.add(ambientLight);
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(5, 5, 5);
          scene.add(directionalLight);

          let model = null;
          let mixer = null;
          let isDragging = false;
          let previousMousePosition = { x: 0, y: 0 };
          let rotationX = 0;
          let rotationY = 0;
          const MAX_ROT_DEG = 30;
          const MAX_ROT = (MAX_ROT_DEG * Math.PI) / 180;

          // Mouse drag rotation
          canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
          });

          canvas.addEventListener('mousemove', (e) => {
            if (!isDragging || !model) return;
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            rotationY = Math.max(-MAX_ROT, Math.min(MAX_ROT, rotationY + deltaX * 0.01));
            rotationX = Math.max(-MAX_ROT, Math.min(MAX_ROT, rotationX + deltaY * 0.01));
            model.rotation.y = rotationY;
            model.rotation.x = rotationX;
            previousMousePosition = { x: e.clientX, y: e.clientY };
          });

          canvas.addEventListener('mouseup', () => {
            isDragging = false;
            if (model) autoRotY = model.rotation.y;
          });

          canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            if (model) autoRotY = model.rotation.y;
          });

          // Touch support
          canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          });

          canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDragging || !model) return;
            const deltaX = e.touches[0].clientX - previousMousePosition.x;
            const deltaY = e.touches[0].clientY - previousMousePosition.y;
            rotationY = Math.max(-MAX_ROT, Math.min(MAX_ROT, rotationY + deltaX * 0.01));
            rotationX = Math.max(-MAX_ROT, Math.min(MAX_ROT, rotationX + deltaY * 0.01));
            model.rotation.y = rotationY;
            model.rotation.x = rotationX;
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          });

          canvas.addEventListener('touchend', () => {
            isDragging = false;
            if (model) autoRotY = model.rotation.y;
          });

          // Auto rotation animation
          let autoRotDir = 1;
          let autoRotY = 0;
          const AUTO_SPEED = 0.008 / 3;
          const HALF_MAX = MAX_ROT / 2;
          const clock = new THREE.Clock();
          
          function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            if (mixer) {
              mixer.update(delta);
            }
            
            if (model && !isDragging) {
              autoRotY += autoRotDir * AUTO_SPEED;
              if (autoRotY >= HALF_MAX) { autoRotY = HALF_MAX; autoRotDir = -1; }
              if (autoRotY <= -HALF_MAX) { autoRotY = -HALF_MAX; autoRotDir = 1; }
              model.rotation.y = autoRotY;
              model.rotation.x = 0;
            }
            renderer.render(scene, camera);
          }
          animate();

          // Load GLB model
          let LoaderClass = null;
          if (typeof THREE.GLTFLoader !== 'undefined') {
            LoaderClass = THREE.GLTFLoader;
            console.log('Using THREE.GLTFLoader');
          } else if (typeof GLTFLoader !== 'undefined') {
            LoaderClass = GLTFLoader;
            console.log('Using GLTFLoader');
          } else {
            console.error('GLTFLoader not available');
            return;
          }
          const loader = new LoaderClass();
          console.log('Loading Alen model: ./alen-model.glb');
          loader.load(
            './alen-model.glb',
            (gltf) => {
              console.log('Alen model loaded successfully!');
              model = gltf.scene;
              scene.add(model);

              // Setup animation mixer if animations exist
              if (gltf.animations && gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(model);
                gltf.animations.forEach((clip) => {
                  mixer.clipAction(clip).play();
                });
              }

              // Center and scale model (75x smaller, 2x larger than before)
              const box = new THREE.Box3().setFromObject(model);
              const center = box.getCenter(new THREE.Vector3());
              const size = box.getSize(new THREE.Vector3());
              const maxDim = Math.max(size.x, size.y, size.z);
              const scale = (2.0 / maxDim) / 75;
              model.scale.multiplyScalar(scale);
              model.position.x = -center.x * scale;
              model.position.y = -center.y * scale - 1.35;
              model.position.z = -center.z * scale;
              console.log('Alen model positioned and scaled');
            },
            (progress) => {
              if (progress.total > 0) {
                const percent = (progress.loaded / progress.total) * 100;
                console.log('Loading Alen model: ' + Math.round(percent) + '%');
              }
            },
            (error) => {
              console.error('Error loading Alen 3D model:', error);
              alen3DInitialized = false; // Allow retry
            }
          );

          // Handle resize
          function handleResize() {
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight || 300;
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
          }
          window.addEventListener('resize', handleResize);
        }

        // Physical Parameters panel 3D model
        let physical3DInitialized = false;
        function initPhysical3D() {
          if (physical3DInitialized) return;
          const canvas = document.getElementById('physical3dCanvas');
          if (!canvas) {
            setTimeout(initPhysical3D, 200);
            return;
          }
          if (typeof THREE === 'undefined' || (typeof THREE.GLTFLoader === 'undefined' && typeof GLTFLoader === 'undefined')) {
            setTimeout(initPhysical3D, 300);
            return;
          }
          const container = canvas.parentElement;
          if (!container) { setTimeout(initPhysical3D, 200); return; }
          const width = container.clientWidth || 280;
          const height = container.clientHeight || 220;
          if (width === 0 || height === 0) {
            setTimeout(initPhysical3D, 200);
            return;
          }
          physical3DInitialized = true;

          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
          camera.position.set(0, 0, 2.5);
          const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
          renderer.setSize(width, height);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          renderer.setClearColor(0x000000, 0);

          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          scene.add(ambientLight);
          const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
          dirLight.position.set(5, 5, 5);
          scene.add(dirLight);

          let model = null;
          let mixer = null;
          let autoRotY = 0;
          const LoaderClass = typeof THREE.GLTFLoader !== 'undefined' ? THREE.GLTFLoader : GLTFLoader;
          const loader = new LoaderClass();
          loader.load(
            './alen-physical-model.glb',
            function(gltf) {
              model = gltf.scene;
              scene.add(model);
              if (gltf.animations && gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(model);
                gltf.animations.forEach(function(clip) { mixer.clipAction(clip).play(); });
              }
              const box = new THREE.Box3().setFromObject(model);
              const center = box.getCenter(new THREE.Vector3());
              const size = box.getSize(new THREE.Vector3());
              const maxDim = Math.max(size.x, size.y, size.z);
              const scale = (1.8 / maxDim) / 2 * 3 * 0.6;
              model.scale.multiplyScalar(scale);
              model.position.x = -center.x * scale;
              model.position.y = -center.y * scale - 0.3;
              model.position.z = -center.z * scale;
            },
            undefined,
            function(err) {
              console.error('Physical 3D model load error:', err);
              physical3DInitialized = false;
            }
          );

          const MAX_ROT_DEG = 25;
          const MAX_ROT = (MAX_ROT_DEG * Math.PI) / 180;
          let autoRotDir = 1;
          const AUTO_SPEED = 0.0012;
          const clock = new THREE.Clock();
          function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            if (model) {
              autoRotY += autoRotDir * AUTO_SPEED;
              if (autoRotY >= MAX_ROT) { autoRotY = MAX_ROT; autoRotDir = -1; }
              if (autoRotY <= -MAX_ROT) { autoRotY = -MAX_ROT; autoRotDir = 1; }
              model.rotation.y = autoRotY;
            }
            renderer.render(scene, camera);
          }
          animate();

          function onResize() {
            const w = container.clientWidth || 280;
            const h = container.clientHeight || 220;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
          }
          window.addEventListener('resize', onResize);
        }

        // Initialize Alen 3D model when main content is visible
        function initAlen3DWhenReady() {
          const mainContentEl = document.getElementById('mainContent');
          if (mainContentEl) {
            const isVisible = mainContentEl.style.display === 'block' || 
                             mainContentEl.style.display === '' ||
                             window.getComputedStyle(mainContentEl).display !== 'none';
            if (isVisible) {
              console.log('Main content visible, initializing Alen 3D model...');
              setTimeout(initAlen3D, 500);
              setTimeout(initPhysical3D, 1500);
            } else {
              setTimeout(initAlen3DWhenReady, 200);
            }
          } else {
            setTimeout(initAlen3DWhenReady, 200);
          }
        }
        
        // Try to init immediately if content is already visible
        document.addEventListener('DOMContentLoaded', function() {
          setTimeout(initAlen3DWhenReady, 1000);
        });
        
        // Also try after load event
        window.addEventListener('load', function() {
          setTimeout(initAlen3DWhenReady, 2000);
        });

        let lalo3DInitialized = false;
        function initLalo3D() {
          if (lalo3DInitialized) return;
          
          const canvas = document.getElementById('lalo3dCanvas');
          if (!canvas) {
            console.log('Canvas not found, retrying...');
            setTimeout(initLalo3D, 200);
            return;
          }
          
          if (typeof THREE === 'undefined') {
            console.log('THREE.js not loaded, retrying...');
            setTimeout(initLalo3D, 200);
            return;
          }

          if (typeof THREE.GLTFLoader === 'undefined' && typeof GLTFLoader === 'undefined') {
            console.log('GLTFLoader not loaded, trying to load...');
            // Load GLTFLoader - it should be available as THREE.GLTFLoader or GLTFLoader
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js';
            script.onload = function() {
              console.log('GLTFLoader script loaded, checking availability...');
              // Wait a bit for the loader to initialize
              setTimeout(function() {
                if (typeof THREE.GLTFLoader !== 'undefined') {
                  console.log('THREE.GLTFLoader is available');
                  setTimeout(initLalo3D, 100);
                } else if (typeof GLTFLoader !== 'undefined') {
                  console.log('GLTFLoader is available');
                  setTimeout(initLalo3D, 100);
                } else {
                  console.error('GLTFLoader loaded but not accessible');
                  setTimeout(initLalo3D, 500);
                }
              }, 200);
            };
            script.onerror = function() {
              console.error('Failed to load GLTFLoader script');
              setTimeout(initLalo3D, 1000);
            };
            document.head.appendChild(script);
            return;
          }

          const container = canvas.parentElement;
          if (!container) {
            console.log('Container not found, retrying...');
            setTimeout(initLalo3D, 200);
            return;
          }
          
          const width = container.clientWidth || 300;
          const height = container.clientHeight || 200;
          
          if (width === 0 || height === 0) {
            console.log('Container has zero size, retrying...', width, height);
            setTimeout(initLalo3D, 200);
            return;
          }
          
          lalo3DInitialized = true;
          console.log('Initializing 3D model...');

          // Scene setup
          const scene = new THREE.Scene();

          const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
          camera.position.set(0, 0, 3);

          const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
          renderer.setSize(width, height);
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.setClearColor(0x000000, 0);

          // Lighting
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          scene.add(ambientLight);
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(5, 5, 5);
          scene.add(directionalLight);

          let model = null;
          let isDragging = false;
          let previousMousePosition = { x: 0, y: 0 };
          let rotationX = 0;
          let rotationY = 0;
          const MAX_ROT_DEG = 30;
          const MAX_ROT = (MAX_ROT_DEG * Math.PI) / 180;

          // Mouse drag rotation (clamp to 30 deg)
          canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
          });

          canvas.addEventListener('mousemove', (e) => {
            if (!isDragging || !model) return;
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            rotationY = Math.max(-MAX_ROT, Math.min(MAX_ROT, rotationY + deltaX * 0.01));
            rotationX = Math.max(-MAX_ROT, Math.min(MAX_ROT, rotationX + deltaY * 0.01));
            model.rotation.y = rotationY;
            model.rotation.x = rotationX;
            previousMousePosition = { x: e.clientX, y: e.clientY };
          });

          canvas.addEventListener('mouseup', () => {
            isDragging = false;
            if (model) autoRotY = model.rotation.y;
          });

          canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            if (model) autoRotY = model.rotation.y;
          });

          // Touch support
          canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          });

          canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDragging || !model) return;
            const deltaX = e.touches[0].clientX - previousMousePosition.x;
            const deltaY = e.touches[0].clientY - previousMousePosition.y;
            rotationY = Math.max(-MAX_ROT, Math.min(MAX_ROT, rotationY + deltaX * 0.01));
            rotationX = Math.max(-MAX_ROT, Math.min(MAX_ROT, rotationX + deltaY * 0.01));
            model.rotation.y = rotationY;
            model.rotation.x = rotationX;
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          });

          canvas.addEventListener('touchend', () => {
            isDragging = false;
            if (model) autoRotY = model.rotation.y;
          });

          // Start animation loop (swing ±15 deg = 30 deg total)
          let autoRotDir = 1;
          let autoRotY = 0;
          const AUTO_SPEED = 0.008 / 3;
          const HALF_MAX = MAX_ROT / 2;
          function animate() {
            requestAnimationFrame(animate);
            if (model && !isDragging) {
              autoRotY += autoRotDir * AUTO_SPEED;
              if (autoRotY >= HALF_MAX) { autoRotY = HALF_MAX; autoRotDir = -1; }
              if (autoRotY <= -HALF_MAX) { autoRotY = -HALF_MAX; autoRotDir = 1; }
              model.rotation.y = autoRotY;
              model.rotation.x = 0;
            }
            renderer.render(scene, camera);
          }
          animate();

          // Load GLB model
          let LoaderClass = null;
          if (typeof THREE.GLTFLoader !== 'undefined') {
            LoaderClass = THREE.GLTFLoader;
            console.log('Using THREE.GLTFLoader');
          } else if (typeof GLTFLoader !== 'undefined') {
            LoaderClass = GLTFLoader;
            console.log('Using GLTFLoader');
          } else {
            console.error('GLTFLoader not available');
            return;
          }
          const loader = new LoaderClass();
          console.log('Loading model: ./lalo-model.glb');
          loader.load(
            './lalo-model.glb',
            (gltf) => {
              console.log('Model loaded successfully!');
              model = gltf.scene;
              scene.add(model);

              // Center and scale model
              const box = new THREE.Box3().setFromObject(model);
              const center = box.getCenter(new THREE.Vector3());
              const size = box.getSize(new THREE.Vector3());
              const maxDim = Math.max(size.x, size.y, size.z);
              const scale = 2.0 / maxDim;
              model.scale.multiplyScalar(scale);
              model.position.x = -center.x * scale;
              model.position.y = -center.y * scale + 0.1;
              model.position.z = -center.z * scale;
              console.log('Model positioned and scaled');
            },
            (progress) => {
              if (progress.total > 0) {
                const percent = (progress.loaded / progress.total) * 100;
                console.log('Loading model: ' + Math.round(percent) + '%');
              }
            },
            (error) => {
              console.error('Error loading 3D model:', error);
              lalo3DInitialized = false; // Allow retry
            }
          );

          // Handle resize
          function handleResize() {
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight || 200;
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
          }
          window.addEventListener('resize', handleResize);
        }

        // Initialize 3D model when main content is visible
        function init3DWhenReady() {
          const mainContentEl = document.getElementById('mainContent');
          if (mainContentEl) {
            const isVisible = mainContentEl.style.display === 'block' || 
                             mainContentEl.style.display === '' ||
                             window.getComputedStyle(mainContentEl).display !== 'none';
            if (isVisible) {
              console.log('Main content visible, initializing 3D model...');
              setTimeout(initLalo3D, 500);
            } else {
              setTimeout(init3DWhenReady, 200);
            }
          } else {
            setTimeout(init3DWhenReady, 200);
          }
        }
        
        // Try to init immediately if content is already visible
        document.addEventListener('DOMContentLoaded', function() {
          setTimeout(init3DWhenReady, 1000);
        });
        
        // Also try after load event
        window.addEventListener('load', function() {
          setTimeout(init3DWhenReady, 2000);
        });

        // Remove paw prints - not needed for alien theme
        function generateRandomPaws() {
          const container = document.getElementById('pawPrintsContainer');
          if (!container) return;

          // Remove old paw prints
          container.innerHTML = '';

          // Random number of paw prints (between 12 and 20)
          const pawCount = Math.floor(Math.random() * 9) + 12;
          const sizes = [15, 18, 20, 22, 24, 25, 26, 28];

          for (let i = 0; i < pawCount; i++) {
            const paw = document.createElement('div');
            paw.className = 'paw-print';
            
            // Random size
            const size = sizes[Math.floor(Math.random() * sizes.length)];
            paw.style.width = size + 'px';
            paw.style.height = size + 'px';
            
            // Random position (avoiding center area where panels are)
            let x, y;
            do {
              x = Math.random() * 100;
              y = Math.random() * 100;
            } while (
              (x > 15 && x < 25 && y > 10 && y < 90) || // Left sidebar area
              (x > 75 && x < 85 && y > 10 && y < 90) || // Right sidebar area
              (x > 35 && x < 65 && y > 5 && y < 95)     // Center area
            );
            
            paw.style.left = x + '%';
            paw.style.top = y + '%';
            
            container.appendChild(paw);
          }

          // Fade in paw prints
          setTimeout(() => {
            const pawPrints = container.querySelectorAll('.paw-print');
            pawPrints.forEach((paw, index) => {
              setTimeout(() => {
                paw.classList.add('visible');
              }, index * 50); // Staggered appearance
            });
          }, 100);
        }

        function fadeOutPaws() {
          const container = document.getElementById('pawPrintsContainer');
          if (!container) return;

          const pawPrints = container.querySelectorAll('.paw-print');
          pawPrints.forEach((paw) => {
            paw.classList.remove('visible');
            paw.classList.add('fading');
          });
        }

        // Initialize paw prints after main content is shown
        let pawInterval;
        window.addEventListener('load', function() {
          setTimeout(function() {
            const mainContent = document.getElementById('mainContent');
            if (mainContent && mainContent.style.display !== 'none') {
              generateRandomPaws();
              
              // Change paw prints every 15 seconds
              pawInterval = setInterval(() => {
                fadeOutPaws();
                setTimeout(() => {
                  generateRandomPaws();
                }, 2000); // Wait for fade out to complete
              }, 15000);
            }
          }, 2000); // Wait for loading screen to finish
        });

        // Also trigger when main content becomes visible
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
              const mainContent = document.getElementById('mainContent');
              if (mainContent && mainContent.style.display === 'block') {
                setTimeout(() => {
                  if (!document.getElementById('pawPrintsContainer').hasChildNodes()) {
                    generateRandomPaws();
                    
                    // Start interval if not already started
                    if (!pawInterval) {
                      pawInterval = setInterval(() => {
                        fadeOutPaws();
                        setTimeout(() => {
                          generateRandomPaws();
                        }, 2000);
                      }, 15000);
                    }
                  }
                }, 300);
              }
            }
          });
        });

        const mainContentForObserver = document.getElementById('mainContent');
        if (mainContentForObserver) {
          observer.observe(mainContentForObserver, { attributes: true });
        }
      });
    </script>
    </div>
  </body>
  
</html>
